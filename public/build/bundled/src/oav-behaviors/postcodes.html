<html><head><link rel="import" href="../../bower_components/polymer/polymer.html?v=6.1.103">
<link rel="import" href="../../bower_components/lodash-import/lodash.js.html?v=6.1.103">
<link rel="import" href="../../bower_components/iron-ajax/iron-ajax.html?v=6.1.103">

<script src="../../bower_components/moment/min/moment-with-locales.min.js"></script>

<script>

  /**
   * @polymerBehavior postCodesBehavior
   */
  Polymer.postCodesBehavior = {

    properties: {
      postCodes: {
        type: Object,
        value: null
      },

      postCodesAreas: {
        type: Object,
        value: null
      },

      postCodesAreasNames: {
        type: Object,
        value: null
      }

    },

    _CSVToArray: function( strData, strDelimiter ) {
      // Check to see if the delimiter is defined. If not,
      // then default to comma.
      strDelimiter = (strDelimiter || ",");

      // Create a regular expression to parse the CSV values.
      var objPattern = new RegExp(
        (
          // Delimiters.
          "(\\" + strDelimiter + "|\\r?\\n|\\r|^)" +

          // Quoted fields.
          "(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +

          // Standard fields.
          "([^\"\\" + strDelimiter + "\\r\\n]*))"
        ),
        "gi"
      );


      // Create an array to hold our data. Give the array
      // a default empty first row.
      var arrData = [[]];

      // Create an array to hold our individual pattern
      // matching groups.
      var arrMatches = null;


      // Keep looping over the regular expression matches
      // until we can no longer find a match.
      while (arrMatches = objPattern.exec( strData )){

        // Get the delimiter that was found.
        var strMatchedDelimiter = arrMatches[ 1 ];

        // Check to see if the given delimiter has a length
        // (is not the start of string) and if it matches
        // field delimiter. If id does not, then we know
        // that this delimiter is a row delimiter.
        if (
          strMatchedDelimiter.length &&
          strMatchedDelimiter !== strDelimiter
        ){

          // Since we have reached a new row of data,
          // add an empty row to our data array.
          arrData.push( [] );

        }

        var strMatchedValue;

        // Now that we have our delimiter out of the way,
        // let's check to see which kind of value we
        // captured (quoted or unquoted).
        if (arrMatches[ 2 ]){

          // We found a quoted value. When we capture
          // this value, unescape any double quotes.
          strMatchedValue = arrMatches[ 2 ].replace(
            new RegExp( "\"\"", "g" ),
            "\""
          );

        } else {

          // We found a non-quoted value.
          strMatchedValue = arrMatches[ 3 ];

        }


        // Now that we have our value string, let's add
        // it to the data array.
        arrData[ arrData.length - 1 ].push( strMatchedValue );
      }

      // Return the parsed data.
      return( arrData );
    },

    nameToAreaId: {
      "The Ferry": 8,
      "East End": 7,
      "North East": 6,
      "Maryfield": 5,
      "Coldside": 4,
      "Strathmartine": 3,
      "West End": 2,
      "Lochee": 1
    },

    setPostCodes: function (blob) {
      var reader = new FileReader();

      reader.addEventListener('loadend', function (e) {
        var text = e.srcElement.result;
        var postCodes = this._CSVToArray(text);
        this.postCodes = {};
        this.postCodesAreas = {};
        this.postCodesAreasNames = {};
        postCodes.forEach(function (code) {
          if (code[1]) {
            var postCode = code[1].replace(/\s/g, "").toUpperCase();
            var areaId = this.nameToAreaId[code[0]];
            if (!this.postCodes[areaId]) {
              this.postCodes[areaId] = [];
            }
            this.postCodes[areaId].push(postCode);
            this.postCodesAreas[postCode]=areaId;
            this.postCodesAreasNames[postCode]=code[0];
          }
        }.bind(this));
      }.bind(this));

      reader.readAsText(blob);
    },

    isValidPostcode: function (areaId,postCode) {
      postCode = postCode.replace(/\s/g, "").toUpperCase();
      return (this.postCodes[areaId].indexOf(postCode) > -1)
    },

    getAreaForPostCode: function (postCode) {
      postCode = postCode.replace(/\s/g, "").toUpperCase();
      return { id: this.postCodesAreas[postCode], name: this.postCodesAreasNames[postCode] };
    }
  };
</script>
</head><body></body></html>